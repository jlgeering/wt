const std = @import("std");
const config_mod = @import("config.zig");
const init_rules = @import("init_rules.zig");

pub const Section = init_rules.Section;

pub const Recommendation = struct {
    rule_id: []const u8,
    section: Section,
    value: []u8,
    prompt: []const u8,
    reason: []const u8,
};

pub const AntiPattern = struct {
    section: Section,
    value: []u8,
    message: []const u8,
};

pub const ChangeKind = enum {
    add,
    remove,
};

pub const Change = struct {
    kind: ChangeKind,
    section: Section,
    value: []u8,
};

pub const EditableConfig = struct {
    allocator: std.mem.Allocator,
    copy_paths: std.ArrayList([]u8),
    symlink_paths: std.ArrayList([]u8),
    run_commands: std.ArrayList([]u8),

    pub fn init(allocator: std.mem.Allocator) EditableConfig {
        return .{
            .allocator = allocator,
            .copy_paths = std.ArrayList([]u8).init(allocator),
            .symlink_paths = std.ArrayList([]u8).init(allocator),
            .run_commands = std.ArrayList([]u8).init(allocator),
        };
    }

    pub fn fromConfig(allocator: std.mem.Allocator, cfg: config_mod.Config) !EditableConfig {
        var editable = EditableConfig.init(allocator);
        errdefer editable.deinit();

        for (cfg.copyPaths()) |value| {
            _ = try editable.add(.copy, value);
        }
        for (cfg.symlinkPaths()) |value| {
            _ = try editable.add(.symlink, value);
        }
        for (cfg.runCommands()) |value| {
            _ = try editable.add(.run, value);
        }

        return editable;
    }

    pub fn clone(self: *const EditableConfig, allocator: std.mem.Allocator) !EditableConfig {
        var copy = EditableConfig.init(allocator);
        errdefer copy.deinit();

        for (self.copy_paths.items) |value| {
            _ = try copy.add(.copy, value);
        }
        for (self.symlink_paths.items) |value| {
            _ = try copy.add(.symlink, value);
        }
        for (self.run_commands.items) |value| {
            _ = try copy.add(.run, value);
        }

        return copy;
    }

    pub fn deinit(self: *EditableConfig) void {
        freeList(self.allocator, &self.copy_paths);
        freeList(self.allocator, &self.symlink_paths);
        freeList(self.allocator, &self.run_commands);
    }

    pub fn contains(self: *const EditableConfig, section: Section, value: []const u8) bool {
        const section_items = self.listConst(section);
        for (section_items.items) |existing| {
            if (std.mem.eql(u8, existing, value)) return true;
        }
        return false;
    }

    pub fn add(self: *EditableConfig, section: Section, value: []const u8) !bool {
        var section_items = self.list(section);
        for (section_items.items) |existing| {
            if (std.mem.eql(u8, existing, value)) return false;
        }

        const duped = try self.allocator.dupe(u8, value);
        try section_items.append(duped);
        return true;
    }

    pub fn remove(self: *EditableConfig, section: Section, value: []const u8) bool {
        var section_items = self.list(section);
        var i: usize = 0;
        while (i < section_items.items.len) : (i += 1) {
            if (std.mem.eql(u8, section_items.items[i], value)) {
                self.allocator.free(section_items.items[i]);
                _ = section_items.orderedRemove(i);
                return true;
            }
        }
        return false;
    }

    pub fn renderToml(self: *const EditableConfig, allocator: std.mem.Allocator) ![]u8 {
        const copy_sorted = try cloneSortedStrings(allocator, self.copy_paths.items);
        defer freeStringSlice(allocator, copy_sorted);

        const symlink_sorted = try cloneSortedStrings(allocator, self.symlink_paths.items);
        defer freeStringSlice(allocator, symlink_sorted);

        const run_sorted = try cloneSortedStrings(allocator, self.run_commands.items);
        defer freeStringSlice(allocator, run_sorted);

        var out = std.ArrayList(u8).init(allocator);
        errdefer out.deinit();

        const writer = out.writer();
        try writer.writeAll("# Generated by `wt init`\n");
        try writer.writeAll("# Edit this file to customize new-worktree setup.\n\n");

        try writer.writeAll("[copy]\n");
        try writeStringArray(writer, "paths", copy_sorted);
        try writer.writeAll("\n");

        try writer.writeAll("[symlink]\n");
        try writeStringArray(writer, "paths", symlink_sorted);
        try writer.writeAll("\n");

        try writer.writeAll("[run]\n");
        try writeStringArray(writer, "commands", run_sorted);

        return out.toOwnedSlice();
    }

    fn list(self: *EditableConfig, section: Section) *std.ArrayList([]u8) {
        return switch (section) {
            .copy => &self.copy_paths,
            .symlink => &self.symlink_paths,
            .run => &self.run_commands,
        };
    }

    fn listConst(self: *const EditableConfig, section: Section) *const std.ArrayList([]u8) {
        return switch (section) {
            .copy => &self.copy_paths,
            .symlink => &self.symlink_paths,
            .run => &self.run_commands,
        };
    }
};

pub fn discoverRecommendations(allocator: std.mem.Allocator, repo_root: []const u8) ![]Recommendation {
    var recs = std.ArrayList(Recommendation).init(allocator);
    errdefer {
        for (recs.items) |rec| allocator.free(rec.value);
    }
    defer recs.deinit();

    const root_entries = try readRootEntries(allocator, repo_root);
    defer freeStringSlice(allocator, root_entries);

    var triggered_rule_ids = std.StringHashMap(void).init(allocator);
    defer triggered_rule_ids.deinit();

    for (init_rules.path_rules) |rule| {
        const matched = try discoverForPathRule(allocator, repo_root, root_entries, rule, &recs);
        if (matched) {
            try triggered_rule_ids.put(rule.id, {});
        }
    }

    for (init_rules.command_rules) |rule| {
        var triggered = false;
        for (rule.trigger_rule_ids) |id| {
            if (triggered_rule_ids.contains(id)) {
                triggered = true;
                break;
            }
        }
        if (!triggered) continue;

        _ = try addRecommendationIfMissing(allocator, &recs, .{
            .rule_id = rule.id,
            .section = rule.section,
            .value = rule.command,
            .prompt = rule.prompt,
            .reason = rule.reason,
        });
    }

    return recs.toOwnedSlice();
}

pub fn detectAntiPatterns(allocator: std.mem.Allocator, cfg: *const EditableConfig) ![]AntiPattern {
    var findings = std.ArrayList(AntiPattern).init(allocator);
    errdefer {
        for (findings.items) |finding| allocator.free(finding.value);
    }
    defer findings.deinit();

    for (cfg.copy_paths.items) |copy_path| {
        if (cfg.contains(.symlink, copy_path)) {
            _ = try addAntiPatternIfMissing(allocator, &findings, .{
                .section = .copy,
                .value = copy_path,
                .message = "Path appears in both copy.paths and symlink.paths. Prefer one strategy.",
            });
        }
    }

    for (init_rules.path_anti_patterns) |rule| {
        const list = switch (rule.section) {
            .copy => cfg.copy_paths.items,
            .symlink => cfg.symlink_paths.items,
            .run => cfg.run_commands.items,
        };
        for (list) |value| {
            if (init_rules.matchesPattern(rule.pattern, value)) {
                _ = try addAntiPatternIfMissing(allocator, &findings, .{
                    .section = rule.section,
                    .value = value,
                    .message = rule.message,
                });
            }
        }
    }

    for (cfg.run_commands.items) |command| {
        for (init_rules.run_anti_patterns) |rule| {
            if (std.mem.indexOf(u8, command, rule.token) != null) {
                _ = try addAntiPatternIfMissing(allocator, &findings, .{
                    .section = .run,
                    .value = command,
                    .message = rule.message,
                });
            }
        }
    }

    return findings.toOwnedSlice();
}

pub fn diffConfigs(allocator: std.mem.Allocator, before: *const EditableConfig, after: *const EditableConfig) ![]Change {
    var changes = std.ArrayList(Change).init(allocator);
    errdefer {
        for (changes.items) |change| allocator.free(change.value);
    }
    defer changes.deinit();

    const sections = [_]Section{ .copy, .symlink, .run };

    for (sections) |section| {
        const after_list = after.listConst(section).items;
        for (after_list) |value| {
            if (!before.contains(section, value)) {
                try changes.append(.{
                    .kind = .add,
                    .section = section,
                    .value = try allocator.dupe(u8, value),
                });
            }
        }

        const before_list = before.listConst(section).items;
        for (before_list) |value| {
            if (!after.contains(section, value)) {
                try changes.append(.{
                    .kind = .remove,
                    .section = section,
                    .value = try allocator.dupe(u8, value),
                });
            }
        }
    }

    return changes.toOwnedSlice();
}

pub fn freeRecommendations(allocator: std.mem.Allocator, recs: []Recommendation) void {
    for (recs) |rec| allocator.free(rec.value);
    allocator.free(recs);
}

pub fn freeAntiPatterns(allocator: std.mem.Allocator, findings: []AntiPattern) void {
    for (findings) |finding| allocator.free(finding.value);
    allocator.free(findings);
}

pub fn freeChanges(allocator: std.mem.Allocator, changes: []Change) void {
    for (changes) |change| allocator.free(change.value);
    allocator.free(changes);
}

pub fn sectionName(section: Section) []const u8 {
    return switch (section) {
        .copy => "copy.paths",
        .symlink => "symlink.paths",
        .run => "run.commands",
    };
}

fn freeList(allocator: std.mem.Allocator, list: *std.ArrayList([]u8)) void {
    for (list.items) |item| allocator.free(item);
    list.deinit();
}

fn readRootEntries(allocator: std.mem.Allocator, repo_root: []const u8) ![]([]u8) {
    var entries = std.ArrayList([]u8).init(allocator);
    errdefer freeStringItems(allocator, entries.items);
    defer entries.deinit();

    var dir = try std.fs.cwd().openDir(repo_root, .{ .iterate = true });
    defer dir.close();

    var iterator = dir.iterate();
    while (try iterator.next()) |entry| {
        switch (entry.kind) {
            .file, .sym_link => try entries.append(try allocator.dupe(u8, entry.name)),
            else => {},
        }
    }

    return entries.toOwnedSlice();
}

fn discoverForPathRule(
    allocator: std.mem.Allocator,
    repo_root: []const u8,
    root_entries: []([]u8),
    rule: init_rules.PathRule,
    recs: *std.ArrayList(Recommendation),
) !bool {
    var matched = false;

    for (rule.patterns) |pattern| {
        switch (pattern.kind) {
            .exact => {
                if (pathExists(allocator, repo_root, pattern.value)) {
                    matched = true;
                    _ = try addRecommendationIfMissing(allocator, recs, .{
                        .rule_id = rule.id,
                        .section = rule.section,
                        .value = pattern.value,
                        .prompt = rule.prompt,
                        .reason = rule.reason,
                    });
                }
            },
            .prefix, .glob => {
                if (std.mem.indexOfScalar(u8, pattern.value, '/')) |_| {
                    // Prefix/glob matching is intentionally limited to repo-root file names.
                    continue;
                }

                for (root_entries) |entry_name| {
                    if (!init_rules.matchesPattern(pattern, entry_name)) continue;
                    matched = true;
                    _ = try addRecommendationIfMissing(allocator, recs, .{
                        .rule_id = rule.id,
                        .section = rule.section,
                        .value = entry_name,
                        .prompt = rule.prompt,
                        .reason = rule.reason,
                    });
                }
            },
        }
    }

    return matched;
}

fn pathExists(allocator: std.mem.Allocator, root: []const u8, rel_path: []const u8) bool {
    const path = std.fs.path.join(allocator, &.{ root, rel_path }) catch return false;
    defer allocator.free(path);

    if (std.fs.cwd().access(path, .{})) |_| {
        return true;
    } else |_| {
        return false;
    }
}

fn addRecommendationIfMissing(
    allocator: std.mem.Allocator,
    recs: *std.ArrayList(Recommendation),
    candidate: struct {
        rule_id: []const u8,
        section: Section,
        value: []const u8,
        prompt: []const u8,
        reason: []const u8,
    },
) !bool {
    for (recs.items) |existing| {
        if (existing.section == candidate.section and std.mem.eql(u8, existing.value, candidate.value)) {
            return false;
        }
    }

    try recs.append(.{
        .rule_id = candidate.rule_id,
        .section = candidate.section,
        .value = try allocator.dupe(u8, candidate.value),
        .prompt = candidate.prompt,
        .reason = candidate.reason,
    });
    return true;
}

fn addAntiPatternIfMissing(
    allocator: std.mem.Allocator,
    findings: *std.ArrayList(AntiPattern),
    candidate: AntiPattern,
) !bool {
    for (findings.items) |existing| {
        if (existing.section == candidate.section and
            std.mem.eql(u8, existing.value, candidate.value) and
            std.mem.eql(u8, existing.message, candidate.message))
        {
            return false;
        }
    }

    try findings.append(.{
        .section = candidate.section,
        .value = try allocator.dupe(u8, candidate.value),
        .message = candidate.message,
    });
    return true;
}

fn writeStringArray(writer: anytype, key: []const u8, items: []const []u8) !void {
    if (items.len == 0) {
        try writer.print("{s} = []\n", .{key});
        return;
    }

    try writer.print("{s} = [\n", .{key});
    for (items) |item| {
        try writer.writeAll("  ");
        try writeTomlString(writer, item);
        try writer.writeAll(",\n");
    }
    try writer.writeAll("]\n");
}

fn writeTomlString(writer: anytype, value: []const u8) !void {
    try writer.writeByte('"');
    for (value) |c| {
        switch (c) {
            '\\' => try writer.writeAll("\\\\"),
            '"' => try writer.writeAll("\\\""),
            '\n' => try writer.writeAll("\\n"),
            '\r' => try writer.writeAll("\\r"),
            '\t' => try writer.writeAll("\\t"),
            else => try writer.writeByte(c),
        }
    }
    try writer.writeByte('"');
}

fn cloneSortedStrings(allocator: std.mem.Allocator, items: []const []u8) ![]([]u8) {
    var cloned = std.ArrayList([]u8).init(allocator);
    errdefer freeStringItems(allocator, cloned.items);
    defer cloned.deinit();

    for (items) |item| {
        try cloned.append(try allocator.dupe(u8, item));
    }

    insertionSortStrings(cloned.items);
    return cloned.toOwnedSlice();
}

fn insertionSortStrings(items: []([]u8)) void {
    var i: usize = 1;
    while (i < items.len) : (i += 1) {
        const current = items[i];
        var j = i;
        while (j > 0 and std.mem.lessThan(u8, current, items[j - 1])) : (j -= 1) {
            items[j] = items[j - 1];
        }
        items[j] = current;
    }
}

fn freeStringSlice(allocator: std.mem.Allocator, items: []([]u8)) void {
    for (items) |item| allocator.free(item);
    allocator.free(items);
}

fn freeStringItems(allocator: std.mem.Allocator, items: []([]u8)) void {
    for (items) |item| allocator.free(item);
}

test "EditableConfig add remove and render" {
    var cfg = EditableConfig.init(std.testing.allocator);
    defer cfg.deinit();

    try std.testing.expect(try cfg.add(.copy, ".env.local"));
    try std.testing.expect(!try cfg.add(.copy, ".env.local"));
    try std.testing.expect(cfg.contains(.copy, ".env.local"));

    try std.testing.expect(try cfg.add(.run, "mise trust"));
    try std.testing.expect(cfg.remove(.run, "mise trust"));
    try std.testing.expect(!cfg.contains(.run, "mise trust"));

    const toml = try cfg.renderToml(std.testing.allocator);
    defer std.testing.allocator.free(toml);

    try std.testing.expect(std.mem.indexOf(u8, toml, "[copy]") != null);
    try std.testing.expect(std.mem.indexOf(u8, toml, ".env.local") != null);
    try std.testing.expect(std.mem.indexOf(u8, toml, "[run]") != null);
}

test "detectAntiPatterns flags copy-symlink conflicts and risky commands" {
    var cfg = EditableConfig.init(std.testing.allocator);
    defer cfg.deinit();

    _ = try cfg.add(.copy, "mise.local.toml");
    _ = try cfg.add(.symlink, "mise.local.toml");
    _ = try cfg.add(.run, "rm -rf build");

    const findings = try detectAntiPatterns(std.testing.allocator, &cfg);
    defer freeAntiPatterns(std.testing.allocator, findings);

    try std.testing.expect(findings.len >= 2);
}

test "diffConfigs reports added and removed values" {
    var before = EditableConfig.init(std.testing.allocator);
    defer before.deinit();
    _ = try before.add(.copy, "a");

    var after = EditableConfig.init(std.testing.allocator);
    defer after.deinit();
    _ = try after.add(.copy, "b");

    const changes = try diffConfigs(std.testing.allocator, &before, &after);
    defer freeChanges(std.testing.allocator, changes);

    try std.testing.expectEqual(@as(usize, 2), changes.len);
}

test "discoverRecommendations finds file and command suggestions" {
    var tmp = std.testing.tmpDir(.{});
    defer tmp.cleanup();

    try tmp.dir.writeFile(.{ .sub_path = "mise.local.toml", .data = "trust = true\n" });
    try tmp.dir.makePath(".claude");
    try tmp.dir.writeFile(.{ .sub_path = ".claude/settings.local.json", .data = "{ }\n" });

    const root = try tmp.dir.realpathAlloc(std.testing.allocator, ".");
    defer std.testing.allocator.free(root);

    const recs = try discoverRecommendations(std.testing.allocator, root);
    defer freeRecommendations(std.testing.allocator, recs);

    var saw_copy_mise = false;
    var saw_copy_claude = false;
    var saw_mise_trust = false;

    for (recs) |rec| {
        if (rec.section == .copy and std.mem.eql(u8, rec.value, "mise.local.toml")) saw_copy_mise = true;
        if (rec.section == .copy and std.mem.eql(u8, rec.value, ".claude/settings.local.json")) saw_copy_claude = true;
        if (rec.section == .run and std.mem.eql(u8, rec.value, "mise trust")) saw_mise_trust = true;
    }

    try std.testing.expect(saw_copy_mise);
    try std.testing.expect(saw_copy_claude);
    try std.testing.expect(saw_mise_trust);
}
